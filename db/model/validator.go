// Package model contains the types for schema 'public'.
package model

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"
	"fmt"

	"github.com/lib/pq"
)

// Validator represents a row from 'public.validators'.
type Validator struct {
	ID               int64          `json:"id"`                 // id
	ChainID          sql.NullString `json:"chain_id"`           // chain_id
	Address          sql.NullString `json:"address"`            // address
	PubKeyType       sql.NullString `json:"pub_key_type"`       // pub_key_type
	PubKeyValue      sql.NullString `json:"pub_key_value"`      // pub_key_value
	VotingPower      sql.NullInt64  `json:"voting_power"`       // voting_power
	Accum            sql.NullInt64  `json:"accum"`              // accum
	FirstBlockHeight sql.NullInt64  `json:"first_block_height"` // first_block_height
	FirstBlockTime   pq.NullTime    `json:"first_block_time"`   // first_block_time
	CreatedAt        pq.NullTime    `json:"created_at"`         // created_at
	Status           sql.NullInt64  `json:"status"`             // status
	InactiveCode     sql.NullInt64  `json:"inactive_code"`      // inactive_code
	InactiveTime     pq.NullTime    `json:"inactive_time"`      // inactive_time
	InactiveHeight   sql.NullInt64  `json:"inactive_height"`    // inactive_height
	BondHeight       sql.NullInt64  `json:"bond_height"`        // bond_height
	Name             sql.NullString `json:"name"`               // name
	Owner            sql.NullString `json:"owner"`              // owner

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Validator exists in the database.
func (v *Validator) Exists() bool {
	return v._exists
}

// Deleted provides information if the Validator has been deleted from the database.
func (v *Validator) Deleted() bool {
	return v._deleted
}

// Insert inserts the Validator to the database.
func (v *Validator) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if v._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO public.validators (` +
		`chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16` +
		`) RETURNING id`

	// run query
	XOLog(sqlstr, v.ChainID, v.Address, v.PubKeyType, v.PubKeyValue, v.VotingPower, v.Accum, v.FirstBlockHeight, v.FirstBlockTime, v.CreatedAt, v.Status, v.InactiveCode, v.InactiveTime, v.InactiveHeight, v.BondHeight, v.Name, v.Owner)
	err = db.QueryRow(sqlstr, v.ChainID, v.Address, v.PubKeyType, v.PubKeyValue, v.VotingPower, v.Accum, v.FirstBlockHeight, v.FirstBlockTime, v.CreatedAt, v.Status, v.InactiveCode, v.InactiveTime, v.InactiveHeight, v.BondHeight, v.Name, v.Owner).Scan(&v.ID)
	if err != nil {
		return err
	}

	// set existence
	v._exists = true

	return nil
}

// Update updates the Validator in the database.
func (v *Validator) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !v._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if v._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.validators SET (` +
		`chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16` +
		`) WHERE id = $17`

	// run query
	XOLog(sqlstr, v.ChainID, v.Address, v.PubKeyType, v.PubKeyValue, v.VotingPower, v.Accum, v.FirstBlockHeight, v.FirstBlockTime, v.CreatedAt, v.Status, v.InactiveCode, v.InactiveTime, v.InactiveHeight, v.BondHeight, v.Name, v.Owner, v.ID)
	_, err = db.Exec(sqlstr, v.ChainID, v.Address, v.PubKeyType, v.PubKeyValue, v.VotingPower, v.Accum, v.FirstBlockHeight, v.FirstBlockTime, v.CreatedAt, v.Status, v.InactiveCode, v.InactiveTime, v.InactiveHeight, v.BondHeight, v.Name, v.Owner, v.ID)
	return err
}

// Save saves the Validator to the database.
func (v *Validator) Save(db XODB) error {
	if v.Exists() {
		return v.Update(db)
	}

	return v.Insert(db)
}

// Upsert performs an upsert for Validator.
//
// NOTE: PostgreSQL 9.5+ only
func (v *Validator) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if v._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.validators (` +
		`id, chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17` +
		`) ON CONFLICT (id) DO UPDATE SET (` +
		`id, chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner` +
		`) = (` +
		`EXCLUDED.id, EXCLUDED.chain_id, EXCLUDED.address, EXCLUDED.pub_key_type, EXCLUDED.pub_key_value, EXCLUDED.voting_power, EXCLUDED.accum, EXCLUDED.first_block_height, EXCLUDED.first_block_time, EXCLUDED.created_at, EXCLUDED.status, EXCLUDED.inactive_code, EXCLUDED.inactive_time, EXCLUDED.inactive_height, EXCLUDED.bond_height, EXCLUDED.name, EXCLUDED.owner` +
		`)`

	// run query
	XOLog(sqlstr, v.ID, v.ChainID, v.Address, v.PubKeyType, v.PubKeyValue, v.VotingPower, v.Accum, v.FirstBlockHeight, v.FirstBlockTime, v.CreatedAt, v.Status, v.InactiveCode, v.InactiveTime, v.InactiveHeight, v.BondHeight, v.Name, v.Owner)
	_, err = db.Exec(sqlstr, v.ID, v.ChainID, v.Address, v.PubKeyType, v.PubKeyValue, v.VotingPower, v.Accum, v.FirstBlockHeight, v.FirstBlockTime, v.CreatedAt, v.Status, v.InactiveCode, v.InactiveTime, v.InactiveHeight, v.BondHeight, v.Name, v.Owner)
	if err != nil {
		return err
	}

	// set existence
	v._exists = true

	return nil
}

// Delete deletes the Validator from the database.
func (v *Validator) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !v._exists {
		return nil
	}

	// if deleted, bail
	if v._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.validators WHERE id = $1`

	// run query
	XOLog(sqlstr, v.ID)
	_, err = db.Exec(sqlstr, v.ID)
	if err != nil {
		return err
	}

	// set deleted
	v._deleted = true

	return nil
}

// ValidatorsQuery returns offset-limit rows from 'public.validators' filte by filter,
// ordered by "id" in descending order.
func ValidatorFilter(db XODB, filter, sort string, offset, limit int64) ([]*Validator, error) {
	sqlstr := `SELECT ` +
		`id, chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner` +
		` FROM public.validators `

	if filter != "" {
		sqlstr = sqlstr + " WHERE " + filter
	}

	if sort != "" {
		sqlstr = sqlstr + " " + sort
	}

	if limit > 0 {
		sqlstr = sqlstr + fmt.Sprintf(" offset %d limit %d", offset, limit)
	}

	XOLog(sqlstr)
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Validator
	for q.Next() {
		v := Validator{
			_exists: true,
		}

		// scan
		err = q.Scan(&v.ID, &v.ChainID, &v.Address, &v.PubKeyType, &v.PubKeyValue, &v.VotingPower, &v.Accum, &v.FirstBlockHeight, &v.FirstBlockTime, &v.CreatedAt, &v.Status, &v.InactiveCode, &v.InactiveTime, &v.InactiveHeight, &v.BondHeight, &v.Name, &v.Owner)
		if err != nil {
			return nil, err
		}

		res = append(res, &v)
	}

	return res, nil
}

// ValidatorByAddress retrieves a row from 'public.validators' as a Validator.
//
// Generated from index 'validators_address_idx'.
func ValidatorByAddress(db XODB, address sql.NullString) (*Validator, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner ` +
		`FROM public.validators ` +
		`WHERE address = $1`

	// run query
	XOLog(sqlstr, address)
	v := Validator{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, address).Scan(&v.ID, &v.ChainID, &v.Address, &v.PubKeyType, &v.PubKeyValue, &v.VotingPower, &v.Accum, &v.FirstBlockHeight, &v.FirstBlockTime, &v.CreatedAt, &v.Status, &v.InactiveCode, &v.InactiveTime, &v.InactiveHeight, &v.BondHeight, &v.Name, &v.Owner)
	if err != nil {
		return nil, err
	}

	return &v, nil
}

// ValidatorsByChainID retrieves a row from 'public.validators' as a Validator.
//
// Generated from index 'validators_chain_id_idx'.
func ValidatorsByChainID(db XODB, chainID sql.NullString) ([]*Validator, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner ` +
		`FROM public.validators ` +
		`WHERE chain_id = $1`

	// run query
	XOLog(sqlstr, chainID)
	q, err := db.Query(sqlstr, chainID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Validator{}
	for q.Next() {
		v := Validator{
			_exists: true,
		}

		// scan
		err = q.Scan(&v.ID, &v.ChainID, &v.Address, &v.PubKeyType, &v.PubKeyValue, &v.VotingPower, &v.Accum, &v.FirstBlockHeight, &v.FirstBlockTime, &v.CreatedAt, &v.Status, &v.InactiveCode, &v.InactiveTime, &v.InactiveHeight, &v.BondHeight, &v.Name, &v.Owner)
		if err != nil {
			return nil, err
		}

		res = append(res, &v)
	}

	return res, nil
}

// ValidatorByID retrieves a row from 'public.validators' as a Validator.
//
// Generated from index 'validators_pkey'.
func ValidatorByID(db XODB, id int64) (*Validator, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, chain_id, address, pub_key_type, pub_key_value, voting_power, accum, first_block_height, first_block_time, created_at, status, inactive_code, inactive_time, inactive_height, bond_height, name, owner ` +
		`FROM public.validators ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	v := Validator{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&v.ID, &v.ChainID, &v.Address, &v.PubKeyType, &v.PubKeyValue, &v.VotingPower, &v.Accum, &v.FirstBlockHeight, &v.FirstBlockTime, &v.CreatedAt, &v.Status, &v.InactiveCode, &v.InactiveTime, &v.InactiveHeight, &v.BondHeight, &v.Name, &v.Owner)
	if err != nil {
		return nil, err
	}

	return &v, nil
}
